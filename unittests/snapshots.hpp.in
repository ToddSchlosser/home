#pragma once

#include <fc/variant.hpp>
#include <fc/filesystem.hpp>

#include <boost/iostreams/filtering_stream.hpp>
#include <boost/iostreams/copy.hpp>
#include <boost/iostreams/filter/gzip.hpp>

#include <fstream>
#include <sstream>
#include <string>
#include <string_view>
#include <type_traits>

namespace eosio {
   namespace testing {
      namespace snapshot {
         // tags for snapshot type
         struct json {};
         struct binary {};

         struct output {};
         struct input {};
      } // ns eosio::testing::snapshot

      static inline constexpr snapshot::json   json_tag;
      static inline constexpr snapshot::binary binary_tag;
      static inline constexpr snapshot::output output_tag;
      static inline constexpr snapshot::input  input_tag;

      namespace snapshot {
         template <typename T>
         static inline constexpr bool is_json_v   = std::is_same_v<std::decay_t<T>, snapshot::json>;
         template <typename T>
         static inline constexpr bool is_binary_v =std::is_same_v<std::decay_t<T>, snapshot::binary>;
         template <typename T>
         static inline constexpr bool is_output_v =std::is_same_v<std::decay_t<T>, snapshot::output>;
         template <typename T>
         static inline constexpr bool is_input_v  =std::is_same_v<std::decay_t<T>, snapshot::input>;
      } // ns eosio::testing::snapshot

      template <typename TypeTag, typename DirectionTag=snapshot::input>
      struct snapshot_file {
         static constexpr auto base_path = "${CMAKE_BINARY_DIR}/unittests/snapshots/";
         static inline constexpr auto file_suffix() {
            if constexpr (snapshot::is_json_v<TypeTag>)
               return ".json.gz";
            else
               return ".bin.gz";
         }

         snapshot_file(TypeTag, const std::string_view& fn)
            : file( base_path + std::string(fn.data(), fn.size()) + file_suffix() ) {}

         snapshot_file(TypeTag, DirectionTag, const std::string_view& fn)
            : file( base_path + std::string(fn.data(), fn.size()) + file_suffix() ) {}

         ~snapshot_file() {
            file.close();
         }

         auto read_as_string() const {
            boost::iostreams::filtering_streambuf<boost::iostreams::input> buf_in;
            buf_in.push(boost::iostreams::gzip_decompressor());
            buf_in.push(file);
            std::stringstream unzipped;
            boost::iostreams::copy(buf_in, unzipped);
            return unzipped.str();
         }

         auto read() const { 
            if constexpr (snapshot::is_json_v<TypeTag>) {
               return read_as_string();
            } else {
               static_assert(snapshot::is_binary_v<TypeTag>, "unsupported type");
               return fc::json::from_string(read_as_string());
            }
         }

         template <typename Snapshot>
         void write( const Snapshot& snapshot ) {
            if constexpr (snapshot::is_json_v<TypeTag>) {
               fc::json::to_stream(file, snapshot, fc::time_point::maximum());
            } else {
               static_assert(snapshot::is_binary_v<TypeTag>, "unsupported type");
               file.write(snapshot.data(), snapshot.size());
            }
            boost::iostreams::filtering_streambuf<boost::iostreams::input> buf_in;
            buf_in.push(boost::iostreams::gzip_compressor());
            buf_in.push(file);
            boost::iostreams::copy(buf_in, file);
         }

         using file_type = std::conditional_t<snapshot::is_input_v<DirectionTag>,
            std::ifstream, std::ofstream>;

         file_type file;
      };
   } /// eosio::testing
}  /// eosio
