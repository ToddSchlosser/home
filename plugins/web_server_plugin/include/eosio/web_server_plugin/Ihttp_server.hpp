#pragma once

#include <functional>
#include <string>
#include <string_view>

#include <boost/asio/io_context.hpp>

namespace eosio{
namespace web{

/**
 * @brief http header representation
 */
struct IHeader{
   virtual ~IHeader(){};
   virtual std::string_view get(std::string_view name) = 0;
   virtual void set(std::string_view name, std::string_view value) = 0;
};

/**
 * @brief handler to be called on server side for specific path
 * @param chunked set this parameter to true if response consists from few chunks
 * @param body output string for setting body of response
 * @param header header class to specify any custom headers
 */
using server_handler = std::function<uint32_t(bool& chunked /*out*/, 
                                              std::string& body /*out*/,
                                              IHeader& header /*in*/)>;

struct Ihttp_server{
   virtual ~Ihttp_server(){};

   /**
    * @brief initialize server
    * @param context execution context
    * @param host server host to use
    * @param port port to listen
    */
   virtual void init(boost::asio::io_context& context, std::string_view host, uint32_t port) = 0;
   /**
    * @brief method for adding server API
    * @param path http path. server first checks for exact match and if not found
    * it uses string::starts_with so if you specify partial path
    * it will be called for all requests where path starts from this string
    */
   virtual void add_handler(std::string_view path, server_handler callback) = 0;
   /**
    * @brief starts server 
    */
   virtual void run() = 0;
};

struct Ihttps_server : Ihttp_server{
   virtual ~Ihttps_server(){};

   /**
    * @brief initialize TLS part. 
    * Note: dh parameter if used supposed to be generated by implementation
    * @param cert https certificate
    * @param pk private key
    */
   virtual void init_ssl(std::string_view cert, std::string_view pk) = 0;
};

}}