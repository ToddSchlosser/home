#pragma once

#include <string>                               /* string */
#include <string_view>                          /* string_view */
#include <type_traits>                          /* underlying_type */

#include <boost/asio/io_context.hpp>            /* io_context */
#include <boost/asio/ssl/context_base.hpp>      /* password_purpose */
#include <fc/io/datastream.hpp>                 /* fc::datastream */
#include <fc/io/raw.hpp>                        /* fc::raw::pack, unpack */

#include <eosio/chain/exceptions.hpp>           /* uri_parse_exception, etc. */

namespace eosio::web{

namespace{
   using namespace eosio;
}

enum class schema_type : uint8_t {
   NOT_SET,
   HTTP,
   HTTPS
};

template <typename DataStream>
inline DataStream& operator << (DataStream& ds, schema_type schema){
   switch(schema){
      case schema_type::HTTP:
      fc::raw::pack(ds, "http");
      break;
      case schema_type::HTTPS:
      fc::raw::pack(ds, "https");
      break;
      default:
      FC_EXCEPTION(chain::uri_parse_exception, "wrong schema: {s}", ("s", schema));
   }

   return ds;
}

enum class method_type : uint8_t {
   GET,
   POST
};

using port_type = uint16_t;

/**
 * @brief http header representation
 */
struct header_interface{
   virtual ~header_interface(){};
   virtual std::string_view get(std::string_view name) = 0;
   virtual void set(std::string_view name, std::string_view value) = 0;
};

/**
 * @brief handler to be called on server side for specific path
 * @param method GET or POST
 * @param chunked set this parameter to true if response consists from few chunks
 * @param body output string for setting body of response
 * @param header header class to specify any custom headers
 */
using server_handler = std::function<uint32_t(method_type method,
                                              bool& chunked /*out*/, 
                                              std::string& body /*out*/,
                                              header_interface& header /*in*/)>;

/**
 * structure that represents server address
 * @param schema URI schema (HTTP, HTTPS, etc.)
 * @param host host in format of "127.0.0.1"
 * @param port port to use
 */
struct server_address{
   schema_type schema;
   std::string host;
   port_type   port;

   std::string as_string() const;

   bool operator == (const server_address& other) const {
      return std::tie(schema, host, port) 
          == std::tie(other.schema, other.host, other.port);
   }
};

struct http_server_interface{
   virtual ~http_server_interface(){};

   /**
    * @brief initialize server
    * @param address server address
    * @param context execution context
    */
   virtual void init(server_address&& address, boost::asio::io_context* context) = 0;
   /**
    * @brief initialize server
    * @param address server address
    * @param thread_pool_size initialize thread pool with specified size
    */
   virtual void init(server_address&& address, uint8_t thread_pool_size) = 0;
   
   /**
    * @brief method for adding server API
    * @param path http path.
    * @param callback function to be called to fill out server's response
    * @param method GET or POST
    */
   virtual void add_handler(std::string_view path, method_type method, server_handler callback) = 0;
   /**
    * @brief starts server 
    */
   virtual void run() = 0;
   /**
    * @brief stops server 
    */
   virtual void stop() = 0;
};

/**
 * password callback to be used in ssl connection
 */
using password_callback = std::function<std::string(std::size_t, boost::asio::ssl::context_base::password_purpose)>;
std::string empty_callback(std::size_t, boost::asio::ssl::context_base::password_purpose){ return ""; };

struct https_server_interface : virtual http_server_interface{
   virtual ~https_server_interface(){};

   /**
    * @brief initialize TLS part. 
    * Note: dh parameter if used supposed to be generated by implementation
    * @param cert https certificate
    * @param pk private key
    * @param pwd_callback password callback function
    * @param dh parameters for Ephemeral Diffie-Hellman key agreement protocol
    */
   virtual void init_ssl(std::string_view cert, std::string_view pk, password_callback pwd_callback, std::string_view dh) = 0;
};

struct http_server_generic_factory_interface{
   
   virtual ~http_server_generic_factory_interface(){};
   /**
    * @brief creates beast_server instance and initializes it.
    * returns http_server_generic_interface* or https_server_interface* depending on address.schema
    * @param address new server address
    * @param context execution context
    */
   virtual http_server_interface* create_server(server_address&& address, boost::asio::io_context* context) = 0;
};

}

namespace fc{
   template <typename DataStream>
   inline DataStream& operator << (DataStream& ds, const eosio::web::server_address& address){
      fc::raw::pack(ds, address.schema);
      fc::raw::pack(ds, (const char*)"://");
      fc::raw::pack(ds, address.host);
      fc::raw::pack(ds, (const char*)":");
      fc::raw::pack(ds, address.port);

      return ds;
   }

   template <typename DataStream>
   inline DataStream& operator << (DataStream& ds, eosio::web::method_type method){

      switch(method){
         case eosio::web::method_type::GET:
         fc::raw::pack(ds, "GET");
         break;
         case eosio::web::method_type::POST:
         fc::raw::pack(ds, "POST");
         break;
         default:
         FC_EXCEPTION(eosio::chain::uri_parse_exception, "wrong method: ${m}", ("m", method));
      }

      return ds;
   }

   inline void to_variant( const eosio::web::schema_type& schema, fc::variant& var ){
      var = variant(static_cast<std::underlying_type_t<eosio::web::schema_type>>(schema));
   }
   inline void from_variant( const fc::variant& var,  eosio::web::schema_type& schema ){
      schema = static_cast<eosio::web::schema_type>(var.as_uint64());
   }

   inline void to_variant( const eosio::web::method_type& schema, fc::variant& var ){
      var = variant(static_cast<std::underlying_type_t<eosio::web::method_type>>(schema));
   }
   inline void from_variant( const fc::variant& var,  eosio::web::method_type& schema ){
      schema = static_cast<eosio::web::method_type>(var.as_uint64());
   }
}

namespace eosio::web{
   std::string server_address::as_string() const{
      using namespace fc;
      std::vector<char> buffer(fc::raw::pack_size(*this));
      fc::datastream<char*> ds(buffer.data(), buffer.size());
      ds << *this;

      return std::string(buffer.data(), ds.tellp());
   }
}